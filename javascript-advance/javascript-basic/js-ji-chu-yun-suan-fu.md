# JS 基础 - 运算符

EMCA-262 描述了一组可以用于数据值的操作符。包括 **数学操作符、位运算符、关系运算符、相等运算符**。

### 一元操作符

只操作一个值的运算符的为一元运算符。包括了**递增/递减运算**符和**一元加和减**

**递增/递减运算符**

包括了自增`++`和自减`--` ，可以放在数字类型值的前后，两者之间还是有区别的

```javascript
let num1 = 2;
let num2 = 10;
let num3 = ++num1; // 3
let num4 = ++num1 + num2; // 14
```

上述`num1`进行递增运算之后，自身就会加`1`，跟 `num1 + 1` 一样。除了放在变量之前，也可以放在变量之后。

```javascript
let num1 = 2;
let num2 = 10;
let num3 = num1++; // 3
let num4 = num1++ + num2; // 13
console.log(num1); // 4
```

很明显，可以看到两者之间的区别。

如果只有自身进行递增、递减运算时，没有区别，跟 `num1 + 1` 或者 `num1 - 1` 结果一样。

如果跟其他运算符结合在一起，就有了明显区别。前递增首先会递增自身，然后再跟其他运算符运算。而后递增会先跟其他运算符先运算，然后再自身递增。

递减（前后）跟递增的处理方式是一致的。

#### 一元加和减

一元加`+` 和 一元减 `-` 也时很常见的。

如果 `+` 放在number类型值的前面，没有什么区别和自身。

如果 `+` 放在非number类型值的前面，就会进行类型转换，调用`Number()`转型函数，类型转换请看[「JS 基础 - 数据类型」](data-type.md#lei-xing-zhuan-huan)。

同理，一元 `-` 跟 一元加执行一样的规则，唯一不同的是放在数字前面，就会将该值转换为负值。

### 位操作符

位操作符是针对数值的底层运算，也就是操作内存中数值的比特位。

ECMAScript 12 中的所有数值都以 **IEEE 754** 64 位格式存储，但位操作并不直接应用到 64 位表示，而是先把值转换为32 位整数，再进行位操作，之后再把结果转换为 64 位。

对开发者而言，就好像只有 32 位整数一样，因 为 64 位整数存储格式是不可见的。

**有符号整数使用 32 位的前 31 位表示整数值**。第 32 位表示数值的符号，如 0 表示正，1 表示负。这 一位称为**符号位\(sign bit\)**，它的值决定了数值其余部分的格式。

正值以真正的二进制格式存储，即 31 位中的每一位都代表 2 的幂。第一位\(称为第 0 位\)表示 2^0，第二位表示 2^1，依此类推。如果一个位是空的，则以 0 填充，相当于忽略不计。

```javascript
// 数字10的二进制表示 这里空格是为了方便看
let numBinary = 0000 0000 0000 0000 0000 0000 0000 1010
// 用toString计算二进制
(10).toString(2); // 1010
```

负值以一种二补数（补码）的二进制编码存储，如果要计算负数的二进制，要进行三个步骤：

* 确定数值的绝对值二进制 （-10，绝对值 就是 10）
* 计算数值的补数（**反码**），也就是`1`转换为`0`，`0`转换为`1` 
* 给补数加1

这里涉及到了补码和反码，这里对比一下跟源码的区别以及之间是怎么转换的。

在这之前，补充一下二进制之间的**加减乘除**运算规则；

**加运算：**`0+0=0`，`0+1=1`，`1+0=1`，`1+1=10`

```bash
进位      11  
原码     0011
原码     1001
分隔    -----
结果     1100 
```

**减运算：**`1-1=0`，`1-0=1`，`0-0=0`，`0－1 = -1`

```bash
进位    1                   11111
原码     0011              01000000
原码     1001              00001010
分隔    -----            ----------
结果    11100              00110110
```

**乘法运算：**`0×0=0`，`0×1=0`，`1×0=0`，`1×1=1`

```bash
进位        
原码     0011
原码     1001
分隔    -----
结果     0001 
```

**除法运算**：`0÷1=0`，`1÷1=1`

```bash
结果      00111 
分隔      -----      
原码   11|10101   
原码     - 11       
分隔      ----- 
余数       100
原码      - 11 
分隔      ----- 
余数         11
原码       - 11 
分隔      ----- 
余数          0
```

了解了二进制运算之后，接着往下看

```bash
数值 0 --> 原码 0000 
数值 -0 --> 原码 1000
数值运算 0 + (-0) = -0 --> 原码 0000 + 1000 = 1000

上面对0和-0进行十进制和二进制运算 结果都是0 二进制是带符号的
再看数值1和-1之间的运算

数值 1 --> 原码 0001
数值 -1 --> 原码 1001
数值运算 -1 + 1 = 0 --> 原码 1001 + 0001 = 1010 = -2（十进制）
```

可以看到，`-1`和`1`二进制位的和运算不对。因此提出了**反码**的概念。

如果是正数，其反码不变；如果是负数，**符号位不变，其他位取反**。然后再来看上述结果。

```bash
数值 1 --> 原码 0001
数值 -1 --> 原码 1001
数值运算 -1 + 1 = 0 --> 反码 1110 + 0001 = 1111 = -0（十进制）
```

可以看到，结果为带符号位的值-0，但是`-1 + 1 = 0` 不应该带符号位。因此，又提出了**补码**的概念。

如果是正数，则补码不变，如果是负数，则补码在其反码的基础上加 `1`

继续看上述例子

```bash
数值 1 --> 原码 0001
数值 -1 --> 原码 1001
数值运算 -1 + 1 = 0 --> 补码 1111 + 0001 = 0000 = 0（十进制）
```

可以看到，此时结果没有带符号位，结果是正确的。了解了上述基础之后，下面来看下位运算有哪几种，每种是怎么运算的。



